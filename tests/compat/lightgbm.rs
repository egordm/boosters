//! Integration tests for LightGBM model compatibility.
//!
//! High-value tests compare predictions against expected values generated by
//! Python LightGBM fixtures under `tests/test-cases/lightgbm`.

#![cfg(feature = "lightgbm-compat")]

use std::fs::File;
use std::path::PathBuf;

use booste_rs::assert_slices_approx_eq_f64;
use booste_rs::compat::lightgbm::LgbModel;
use serde::Deserialize;

/// Test directory for LightGBM test cases.
fn test_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/test-cases/lightgbm/inference")
}

#[derive(Debug, Deserialize)]
struct TestInput {
    num_samples: usize,
    num_features: usize,
    data: Vec<Vec<Option<f64>>>,
    #[allow(dead_code)]
    labels: Option<Vec<f64>>,
}

impl TestInput {
    fn to_f32_rows(&self) -> Vec<Vec<f32>> {
        self.data
            .iter()
            .map(|row| {
                row.iter()
                    .map(|&x| x.map(|v| v as f32).unwrap_or(f32::NAN))
                    .collect()
            })
            .collect()
    }
}

fn row_to_f32(row: &[Option<f64>]) -> Vec<f32> {
    row.iter()
        .map(|&x| x.map(|v| v as f32).unwrap_or(f32::NAN))
        .collect()
}

#[derive(Debug, Deserialize)]
struct TestExpected {
    raw: RawPredictions,
    #[serde(default)]
    proba: Option<ProbaPredictions>,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum RawPredictions {
    Flat(Vec<f64>),
    Multiclass(Vec<Vec<f64>>),
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ProbaPredictions {
    Flat(Vec<f64>),
    Multiclass(Vec<Vec<f64>>),
}

/// LightGBM uses f64 internally, we use f32.
const TOLERANCE: f64 = 1e-4;

fn load_test_case(subdir: &str) -> (LgbModel, TestInput, TestExpected) {
    let dir = test_dir().join(subdir);

    let model = LgbModel::from_file(dir.join("model.txt"))
        .unwrap_or_else(|e| panic!("Failed to load model from {subdir}: {e}"));

    let input: TestInput = serde_json::from_reader(
        File::open(dir.join("input.json")).expect("input.json missing"),
    )
    .expect("Failed to parse input.json");

    let expected: TestExpected = serde_json::from_reader(
        File::open(dir.join("expected.json")).expect("expected.json missing"),
    )
    .expect("Failed to parse expected.json");

    (model, input, expected)
}

mod regression {
    use super::*;

    #[test]
    fn predictions_match_lightgbm() {
        let (model, input, expected) = load_test_case("regression");
        let forest = model.to_forest().expect("Failed to convert model");
        forest
            .validate()
            .expect("converted forest should be structurally valid");

        assert_eq!(forest.n_groups(), 1);
        assert_eq!(input.num_samples, 20);
        assert_eq!(input.num_features, 10);

        let expected_raw = match &expected.raw {
            RawPredictions::Flat(v) => v,
            RawPredictions::Multiclass(_) => panic!("Expected flat predictions for regression"),
        };

        let predictions: Vec<f32> = input
            .data
            .iter()
            .map(|row| {
                let row_f32 = row_to_f32(row);
                forest.predict_row(&row_f32)[0]
            })
            .collect();

        assert_slices_approx_eq_f64!(&predictions, expected_raw, TOLERANCE, "regression");
    }
}

mod binary_classification {
    use super::*;

    #[test]
    fn raw_predictions_match_lightgbm() {
        let (model, input, expected) = load_test_case("binary_classification");
        let forest = model.to_forest().expect("Failed to convert model");
        forest
            .validate()
            .expect("converted forest should be structurally valid");

        assert_eq!(forest.n_groups(), 1);
        assert_eq!(input.num_samples, 20);

        let expected_raw = match &expected.raw {
            RawPredictions::Flat(v) => v,
            RawPredictions::Multiclass(_) => panic!("Expected flat predictions"),
        };

        let predictions: Vec<f32> = input
            .data
            .iter()
            .map(|row| {
                let row_f32 = row_to_f32(row);
                forest.predict_row(&row_f32)[0]
            })
            .collect();

        assert_slices_approx_eq_f64!(&predictions, expected_raw, TOLERANCE, "binary raw");
    }

    #[test]
    fn probabilities_match_lightgbm() {
        let (model, input, expected) = load_test_case("binary_classification");
        let forest = model.to_forest().expect("Failed to convert model");

        let expected_proba = match &expected.proba {
            Some(ProbaPredictions::Flat(v)) => v,
            _ => panic!("Expected flat probability predictions"),
        };

        let predictions: Vec<f32> = input
            .data
            .iter()
            .map(|row| {
                let row_f32 = row_to_f32(row);
                let raw = forest.predict_row(&row_f32)[0];
                1.0 / (1.0 + (-raw).exp())
            })
            .collect();

        assert_slices_approx_eq_f64!(&predictions, expected_proba, TOLERANCE, "binary proba");
    }
}

mod multiclass {
    use super::*;

    #[test]
    fn raw_predictions_match_lightgbm() {
        let (model, input, expected) = load_test_case("multiclass");
        let forest = model.to_forest().expect("Failed to convert model");
        forest
            .validate()
            .expect("converted forest should be structurally valid");

        assert_eq!(forest.n_groups(), 3);
        assert_eq!(input.num_samples, 20);

        let expected_raw = match &expected.raw {
            RawPredictions::Multiclass(v) => v,
            RawPredictions::Flat(_) => panic!("Expected multiclass predictions"),
        };

        for (i, row) in input.data.iter().enumerate() {
            let row_f32 = row_to_f32(row);
            let pred = forest.predict_row(&row_f32);

            assert_eq!(pred.len(), 3, "Row {i}: expected 3 outputs");
            assert_slices_approx_eq_f64!(&pred, &expected_raw[i], TOLERANCE, "multiclass row {i}");
        }
    }

    #[test]
    fn probabilities_match_lightgbm() {
        let (model, input, expected) = load_test_case("multiclass");
        let forest = model.to_forest().expect("Failed to convert model");

        let expected_proba = match &expected.proba {
            Some(ProbaPredictions::Multiclass(v)) => v,
            _ => panic!("Expected multiclass probability predictions"),
        };

        for (i, row) in input.data.iter().enumerate() {
            let row_f32 = row_to_f32(row);
            let raw = forest.predict_row(&row_f32);

            let max_val = raw.iter().copied().fold(f32::NEG_INFINITY, f32::max);
            let exp_sum: f32 = raw.iter().map(|&x| (x - max_val).exp()).sum();
            let proba: Vec<f32> = raw.iter().map(|&x| (x - max_val).exp() / exp_sum).collect();

            assert_slices_approx_eq_f64!(&proba, &expected_proba[i], TOLERANCE, "multiclass proba row {i}");
        }
    }
}

mod missing_values {
    use super::*;

    #[test]
    fn predictions_match_with_missing() {
        let (model, input, expected) = load_test_case("regression_missing");
        let forest = model.to_forest().expect("Failed to convert model");
        forest
            .validate()
            .expect("converted forest should be structurally valid");

        assert_eq!(forest.n_groups(), 1);

        let expected_raw = match &expected.raw {
            RawPredictions::Flat(v) => v,
            RawPredictions::Multiclass(_) => panic!("Expected flat predictions"),
        };

        let predictions: Vec<f32> = input
            .data
            .iter()
            .map(|row| {
                let row_f32 = row_to_f32(row);
                forest.predict_row(&row_f32)[0]
            })
            .collect();

        assert_slices_approx_eq_f64!(&predictions, expected_raw, TOLERANCE, "regression_missing");
    }

    #[test]
    fn handles_nan_features() {
        let (model, _, _) = load_test_case("regression_missing");
        let forest = model.to_forest().expect("Failed to convert model");

        let mut features: Vec<f32> = vec![0.5; 10];
        features[3] = f32::NAN;
        features[7] = f32::NAN;

        let pred = forest.predict_row(&features);
        assert_eq!(pred.len(), 1);
        assert!(pred[0].is_finite(), "Prediction should be finite with NaN inputs");
    }
}
