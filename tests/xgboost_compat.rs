//! Integration tests for XGBoost JSON model loading and prediction.
//!
//! These tests load real XGBoost models and compare predictions against
//! expected values generated by Python XGBoost.
//!
//! Test case structure:
//! - {name}.model.json    - XGBoost model file
//! - {name}.input.json    - Test input features
//! - {name}.expected.json - Expected predictions (raw margin scores)

#![cfg(feature = "xgboost-compat")]

use std::fs::File;
use std::path::PathBuf;

use serde::Deserialize;

use booste_rs::compat::XgbModel;

// =============================================================================
// Test case structures
// =============================================================================

#[derive(Debug, Deserialize)]
struct TestInput {
    /// Features matrix, where None represents NaN (missing value)
    features: Vec<Vec<Option<f64>>>,
    num_rows: usize,
    num_features: usize,
}

impl TestInput {
    /// Convert input features to f32, mapping None to NaN.
    fn to_f32_rows(&self) -> Vec<Vec<f32>> {
        self.features
            .iter()
            .map(|row| {
                row.iter()
                    .map(|&x| x.map(|v| v as f32).unwrap_or(f32::NAN))
                    .collect()
            })
            .collect()
    }
}

#[derive(Debug, Deserialize)]
struct TestExpected {
    predictions: serde_json::Value, // Can be Vec<f64> or Vec<Vec<f64>>
    #[allow(dead_code)]
    output_margin: bool,
}

fn test_cases_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/test-cases/xgboost")
}

fn load_test_case(name: &str) -> (XgbModel, TestInput, TestExpected) {
    let dir = test_cases_dir();

    let model: XgbModel = serde_json::from_reader(
        File::open(dir.join(format!("{name}.model.json"))).expect("model file"),
    )
    .expect("parse model");

    let input: TestInput = serde_json::from_reader(
        File::open(dir.join(format!("{name}.input.json"))).expect("input file"),
    )
    .expect("parse input");

    let expected: TestExpected = serde_json::from_reader(
        File::open(dir.join(format!("{name}.expected.json"))).expect("expected file"),
    )
    .expect("parse expected");

    (model, input, expected)
}

// =============================================================================
// Parsing tests - verify models can be loaded
// =============================================================================

#[test]
fn parse_regression_model() {
    let (model, input, _) = load_test_case("regression");
    assert_eq!(input.num_features, 5);
    assert_eq!(input.num_rows, 10);
    assert_eq!(model.learner.learner_model_param.num_class, 0);
}

#[test]
fn parse_binary_logistic_model() {
    let (model, input, _) = load_test_case("binary_logistic");
    assert_eq!(input.num_features, 4);
    assert_eq!(model.learner.learner_model_param.num_class, 0);
}

#[test]
fn parse_multiclass_model() {
    let (model, input, _) = load_test_case("multiclass");
    assert_eq!(input.num_features, 4);
    assert_eq!(model.learner.learner_model_param.num_class, 3);
}

#[test]
fn parse_dart_model() {
    let (model, input, _) = load_test_case("dart_regression");
    assert_eq!(input.num_features, 3);
    // DART uses different booster type
    assert!(matches!(
        model.learner.gradient_booster,
        booste_rs::compat::xgboost::GradientBooster::Dart { .. }
    ));
}

#[test]
fn parse_model_with_missing_values() {
    let (model, input, _) = load_test_case("regression_missing");
    assert_eq!(input.num_features, 4);
    // Check that missing values are present in input (None = NaN)
    assert!(input.features[0][0].is_none());
    assert!(input.features[2][1].is_none());
    assert!(input.features[5].iter().all(|x| x.is_none()));
    // Model should convert without error - missing values are handled during traversal
    assert!(model.to_forest().is_ok());
}

// =============================================================================
// Conversion tests - verify models convert to native format
// =============================================================================

#[test]
fn convert_regression_model() {
    let (model, _, _) = load_test_case("regression");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 1);
    assert!(forest.num_trees() > 0);
}

#[test]
fn convert_binary_logistic_model() {
    let (model, _, _) = load_test_case("binary_logistic");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 1);
}

#[test]
fn convert_multiclass_model() {
    let (model, _, _) = load_test_case("multiclass");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 3);
}

#[test]
fn convert_dart_model() {
    let (model, _, _) = load_test_case("dart_regression");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 1);
}

// =============================================================================
// Prediction tests - verify predictions match Python XGBoost
// =============================================================================

const TOLERANCE: f64 = 1e-5;

fn assert_predictions_match(actual: &[f32], expected: &[f64], tolerance: f64) {
    assert_eq!(
        actual.len(),
        expected.len(),
        "prediction count mismatch: got {}, expected {}",
        actual.len(),
        expected.len()
    );
    for (i, (a, e)) in actual.iter().zip(expected.iter()).enumerate() {
        let diff = (*a as f64 - *e).abs();
        assert!(
            diff < tolerance,
            "prediction[{i}] mismatch: got {a}, expected {e}, diff {diff}"
        );
    }
}

#[test]
fn predict_regression() {
    let (model, input, expected) = load_test_case("regression");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_binary_logistic() {
    let (model, input, expected) = load_test_case("binary_logistic");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_multiclass() {
    let (model, input, expected) = load_test_case("multiclass");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    // Multiclass predictions are [num_rows][num_classes]
    let expected_preds: Vec<Vec<f64>> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 3, "expected 3 classes");
        assert_predictions_match(&pred, &expected_preds[i], TOLERANCE);
    }
}

#[test]
fn predict_with_missing_values() {
    let (model, input, expected) = load_test_case("regression_missing");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_dart() {
    let (model, input, expected) = load_test_case("dart_regression");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

// =============================================================================
// Batch prediction test
// =============================================================================

#[test]
fn predict_batch_regression() {
    let (model, input, expected) = load_test_case("regression");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    let feature_refs: Vec<&[f32]> = rows.iter().map(|v| v.as_slice()).collect();
    let predictions = forest.predict_batch(&feature_refs);

    assert_eq!(predictions.len(), expected_preds.len());
    for (i, (pred, exp)) in predictions.iter().zip(expected_preds.iter()).enumerate() {
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - exp).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {exp}, diff {diff}",
            pred[0]
        );
    }
}
