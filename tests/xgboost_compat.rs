//! Integration tests for XGBoost JSON model loading and prediction.
//!
//! These tests load real XGBoost models and compare predictions against
//! expected values generated by Python XGBoost.
//!
//! Test case structure:
//! - {name}.model.json    - XGBoost model file
//! - {name}.input.json    - Test input features
//! - {name}.expected.json - Expected predictions (raw margin scores)

#![cfg(feature = "xgboost-compat")]

use std::fs::File;
use std::path::PathBuf;

use serde::Deserialize;

use booste_rs::compat::XgbModel;

// =============================================================================
// Test case structures
// =============================================================================

#[derive(Debug, Deserialize)]
struct TestInput {
    /// Features matrix, where None represents NaN (missing value)
    features: Vec<Vec<Option<f64>>>,
    num_rows: usize,
    num_features: usize,
}

impl TestInput {
    /// Convert input features to f32, mapping None to NaN.
    fn to_f32_rows(&self) -> Vec<Vec<f32>> {
        self.features
            .iter()
            .map(|row| {
                row.iter()
                    .map(|&x| x.map(|v| v as f32).unwrap_or(f32::NAN))
                    .collect()
            })
            .collect()
    }
}

#[derive(Debug, Deserialize)]
struct TestExpected {
    predictions: serde_json::Value, // Can be Vec<f64> or Vec<Vec<f64>>
    #[allow(dead_code)]
    predictions_transformed: Option<serde_json::Value>, // Transformed predictions (sigmoid/softmax)
    #[allow(dead_code)]
    objective: Option<String>,
    #[allow(dead_code)]
    num_class: Option<u32>,
}

fn test_cases_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/test-cases/xgboost")
}

fn load_test_case(name: &str) -> (XgbModel, TestInput, TestExpected) {
    let dir = test_cases_dir();

    let model: XgbModel = serde_json::from_reader(
        File::open(dir.join(format!("{name}.model.json"))).expect("model file"),
    )
    .expect("parse model");

    let input: TestInput = serde_json::from_reader(
        File::open(dir.join(format!("{name}.input.json"))).expect("input file"),
    )
    .expect("parse input");

    let expected: TestExpected = serde_json::from_reader(
        File::open(dir.join(format!("{name}.expected.json"))).expect("expected file"),
    )
    .expect("parse expected");

    (model, input, expected)
}

// =============================================================================
// Parsing tests - verify models can be loaded
// =============================================================================

#[test]
fn parse_regression_model() {
    let (model, input, _) = load_test_case("regression");
    assert_eq!(input.num_features, 5);
    assert_eq!(input.num_rows, 10);
    assert_eq!(model.learner.learner_model_param.num_class, 0);
}

#[test]
fn parse_binary_logistic_model() {
    let (model, input, _) = load_test_case("binary_logistic");
    assert_eq!(input.num_features, 4);
    assert_eq!(model.learner.learner_model_param.num_class, 0);
}

#[test]
fn parse_multiclass_model() {
    let (model, input, _) = load_test_case("multiclass");
    assert_eq!(input.num_features, 4);
    assert_eq!(model.learner.learner_model_param.num_class, 3);
}

#[test]
fn parse_dart_model() {
    let (model, input, _) = load_test_case("dart_regression");
    assert_eq!(input.num_features, 3);
    // DART uses different booster type
    assert!(matches!(
        model.learner.gradient_booster,
        booste_rs::compat::xgboost::GradientBooster::Dart { .. }
    ));
}

#[test]
fn parse_model_with_missing_values() {
    let (model, input, _) = load_test_case("regression_missing");
    assert_eq!(input.num_features, 4);
    // Check that missing values are present in input (None = NaN)
    assert!(input.features[0][0].is_none());
    assert!(input.features[2][1].is_none());
    assert!(input.features[5].iter().all(|x| x.is_none()));
    // Model should convert without error - missing values are handled during traversal
    assert!(model.to_forest().is_ok());
}

// =============================================================================
// Conversion tests - verify models convert to native format
// =============================================================================

#[test]
fn convert_regression_model() {
    let (model, _, _) = load_test_case("regression");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 1);
    assert!(forest.num_trees() > 0);
}

#[test]
fn convert_binary_logistic_model() {
    let (model, _, _) = load_test_case("binary_logistic");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 1);
}

#[test]
fn convert_multiclass_model() {
    let (model, _, _) = load_test_case("multiclass");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 3);
}

#[test]
fn convert_dart_model() {
    let (model, _, _) = load_test_case("dart_regression");
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_groups(), 1);
}

// =============================================================================
// Prediction tests - verify predictions match Python XGBoost
// =============================================================================

const TOLERANCE: f64 = 1e-5;

fn assert_predictions_match(actual: &[f32], expected: &[f64], tolerance: f64) {
    assert_eq!(
        actual.len(),
        expected.len(),
        "prediction count mismatch: got {}, expected {}",
        actual.len(),
        expected.len()
    );
    for (i, (a, e)) in actual.iter().zip(expected.iter()).enumerate() {
        let diff = (*a as f64 - *e).abs();
        assert!(
            diff < tolerance,
            "prediction[{i}] mismatch: got {a}, expected {e}, diff {diff}"
        );
    }
}

#[test]
fn predict_regression() {
    let (model, input, expected) = load_test_case("regression");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_binary_logistic() {
    let (model, input, expected) = load_test_case("binary_logistic");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_multiclass() {
    let (model, input, expected) = load_test_case("multiclass");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    // Multiclass predictions are [num_rows][num_classes]
    let expected_preds: Vec<Vec<f64>> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 3, "expected 3 classes");
        assert_predictions_match(&pred, &expected_preds[i], TOLERANCE);
    }
}

#[test]
fn predict_with_missing_values() {
    let (model, input, expected) = load_test_case("regression_missing");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_dart() {
    let (model, input, expected) = load_test_case("dart_regression");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

// =============================================================================
// Batch prediction test
// =============================================================================

#[test]
fn predict_batch_regression() {
    let (model, input, expected) = load_test_case("regression");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    let feature_refs: Vec<&[f32]> = rows.iter().map(|v| v.as_slice()).collect();
    let predictions = forest.predict_batch(&feature_refs);

    assert_eq!(predictions.len(), expected_preds.len());
    for (i, (pred, exp)) in predictions.iter().zip(expected_preds.iter()).enumerate() {
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - exp).abs();
        assert!(
            diff < TOLERANCE,
            "row {i}: got {}, expected {exp}, diff {diff}",
            pred[0]
        );
    }
}

// =============================================================================
// Additional test cases for expanded coverage
// =============================================================================

#[test]
fn parse_deep_trees_model() {
    let (model, input, _) = load_test_case("deep_trees");
    assert_eq!(input.num_features, 8);
    assert!(model.to_forest().is_ok());
}

#[test]
fn parse_single_tree_model() {
    let (model, input, _) = load_test_case("single_tree");
    assert_eq!(input.num_features, 3);
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_trees(), 1);
}

#[test]
fn parse_many_trees_model() {
    let (model, input, _) = load_test_case("many_trees");
    assert_eq!(input.num_features, 5);
    let forest = model.to_forest().expect("conversion failed");
    assert_eq!(forest.num_trees(), 50);
}

#[test]
fn parse_wide_features_model() {
    let (model, input, _) = load_test_case("wide_features");
    assert_eq!(input.num_features, 100);
    assert!(model.to_forest().is_ok());
}

#[test]
fn predict_deep_trees() {
    let (model, input, expected) = load_test_case("deep_trees");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "deep_trees row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_single_tree() {
    let (model, input, expected) = load_test_case("single_tree");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "single_tree row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_many_trees() {
    let (model, input, expected) = load_test_case("many_trees");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "many_trees row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn predict_wide_features() {
    let (model, input, expected) = load_test_case("wide_features");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "wide_features row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

// =============================================================================
// Categorical features tests
// =============================================================================

#[test]
fn parse_categorical_model() {
    let (model, _input, _expected) = load_test_case("categorical");

    // Check feature types include categorical
    assert!(!model.learner.feature_types.is_empty());
    let feature_types = &model.learner.feature_types;
    let has_categorical = feature_types
        .iter()
        .any(|ft| matches!(ft, booste_rs::compat::xgboost::FeatureType::Categorical));
    assert!(
        has_categorical,
        "Expected categorical feature type in {:?}",
        feature_types
    );
}

#[test]
fn convert_categorical_model() {
    let (model, _input, _expected) = load_test_case("categorical");
    let forest = model.to_forest().expect("conversion failed");

    assert_eq!(forest.num_groups(), 1);
    assert!(forest.num_trees() > 0);

    // Check that at least one tree has categorical splits
    let mut has_categorical = false;
    for tree_idx in 0..forest.num_trees() {
        if forest.tree(tree_idx).has_categorical() {
            has_categorical = true;
            break;
        }
    }
    assert!(
        has_categorical,
        "Expected at least one tree to have categorical splits"
    );
}

#[test]
fn predict_categorical() {
    let (model, input, expected) = load_test_case("categorical");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "categorical row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}

#[test]
fn parse_categorical_binary_model() {
    let (model, _input, _expected) = load_test_case("categorical_binary");

    let feature_types = &model.learner.feature_types;
    let has_categorical = feature_types
        .iter()
        .any(|ft| matches!(ft, booste_rs::compat::xgboost::FeatureType::Categorical));
    assert!(
        has_categorical,
        "Expected categorical feature type in {:?}",
        feature_types
    );
}

#[test]
fn predict_categorical_binary() {
    let (model, input, expected) = load_test_case("categorical_binary");
    let forest = model.to_forest().expect("conversion failed");
    let rows = input.to_f32_rows();

    let expected_preds: Vec<f64> = serde_json::from_value(expected.predictions).unwrap();

    for (i, features) in rows.iter().enumerate() {
        let pred = forest.predict_row(features);
        assert_eq!(pred.len(), 1);
        let diff = (pred[0] as f64 - expected_preds[i]).abs();
        assert!(
            diff < TOLERANCE,
            "categorical_binary row {i}: got {}, expected {}, diff {diff}",
            pred[0],
            expected_preds[i]
        );
    }
}
